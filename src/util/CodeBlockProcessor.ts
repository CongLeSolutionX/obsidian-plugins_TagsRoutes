import { MarkdownPostProcessorContext, moment, TFile, MarkdownRenderer, MarkdownView, HeadingCache, getFrontMatterInfo, parseFrontMatterTags } from "obsidian"
import  TagsRoutes, { globalProgramControl }  from '../main';
import { getLineTime } from "./util";
export class codeBlockProcessor {
    plugin: TagsRoutes;
    constructor(plugin: TagsRoutes) {
        this.plugin = plugin;
        this.codeBlockProcessor = this.codeBlockProcessor.bind(this);
    }
    private async checkAndGetFrontmatterTag(source: string, el: HTMLElement, ctx: MarkdownPostProcessorContext){
        const tag = source.replace(/frontmatter-tag:/, '').trim();
        const files = this.plugin.app.vault.getMarkdownFiles();
    
        const matchingFiles = await Promise.all(files.map(async (file) => {
            const cache = this.plugin.app.metadataCache.getCache(file.path);
            if (cache?.frontmatter?.tags) {
                let tags = Array.isArray(cache.frontmatter.tags) 
                    ? cache.frontmatter.tags 
                    : [cache.frontmatter.tags];
    
                if (tags.includes("tag-report")) {
                    return null; // Exclude tag-report files
                }
    
                if (tags.some(t => t.includes(tag))) {
               //     console.log(">>find the file have this tag: ", file.path);
                    return file.path;
                }
            }
            return null;
        }));
    
        const result = matchingFiles.filter(path => path !== null) as string[];
        const writeContent = `
# Total \`${result.length}\` notes with tag \`${tag}\` :
${result.map(v => "- [[" + v.replace(/.md$/, "") + "]]").join("\n")}
`;
        this.writeMarkdown("frontmatter-tag: "+tag, writeContent, el, ctx);
    }
    private getTagContent(term: string) {
        const files = this.plugin.app.vault.getMarkdownFiles()
        const arr = files.map(
            async (file) => {
                const content = await this.plugin.app.vault.cachedRead(file)
                const fmi = getFrontMatterInfo(content)
                if (fmi.exists && fmi.frontmatter.contains("tag-report")) {
                    return []
                }
                const lines = content
                    .split(/\n[\ ]*\n/)
                    .filter(line => line.contains(term))
                if (lines.length != 0) {
                    var mmtime
                    var regstr = term + '[\/_# \u4e00-\u9fa5]* +(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})'
                    var regex = new RegExp(regstr, 'g')
                    const retArr = lines.map(
                        (line) => {
                            regex.lastIndex = 0
                            let match = regex.exec(line)
                            if (match) {
                                mmtime = " Tag Time: " + match[1]
                            } else {
                                mmtime = " Created Time: " + moment(file.stat.ctime).format('YYYY-MM-DD HH:mm:ss')
                            }
                            return line + "\n\n \[*From* " + "[[" +
                                file.name.split(".")[0] + "]], *" + mmtime + "*\]\n"
                        }
                    )
                    return retArr
                } else {
                    return []
                }
            }
        )
        return arr;
    }
   async  writeMarkdown(term: string, source: string, el: HTMLElement, ctx: MarkdownPostProcessorContext) {
       const markDownSource = source;

        if (globalProgramControl.useDiv) {
            //el.createEl('pre', {text: markDownSource})
            MarkdownRenderer.render(this.plugin.app,
                markDownSource,
                el.createEl('div'), ctx.sourcePath, this.plugin.app.workspace.getActiveViewOfType(MarkdownView) as MarkdownView
            )
        } else {
            const fileContent = `---\ntags:\n  - tag-report\n---\n
\`\`\`tagsroutes
           ${term}
\`\`\`
*This file is automatically generated and will be overwritten.*
*Please do not edit this file to avoid losing your changes.*
`
            const { vault } = this.plugin.app;

            //need to add only process file under report directory
            const file = vault.getAbstractFileByPath(ctx.sourcePath);
            if (file instanceof TFile) {
                vault.modify(file, fileContent + markDownSource)
            }
        }
    }
    async codeBlockProcessor(source: string, el: HTMLElement, ctx: MarkdownPostProcessorContext) {
        //Bypass the first pass
        if ((ctx.frontmatter as any).tags === undefined) {
        //    console.log("first pass");
            return;
        }

        if (source.contains("frontmatter-tag:")) {
            this.checkAndGetFrontmatterTag(source,el,ctx)
            return;
        }
        const regstr = '(#[\\w\/_\u4e00-\u9fa5]*)'
        const regex = new RegExp(regstr, 'g')
        const match = source.match(regex)
        const term = match ?.[0] || "#empty"
        this.writeMarkdown(term, "<br><div class=\"container-fluid\"><div class=\"tg-alert\"><b>PROCESSING...</b></div><small><em>The first time will be slow depending on vault size.</em></small></div>", el, ctx);
        const con = this.getTagContent(term)
        const markdownText: string[] = [];
        const values = await Promise.all(con);
        const noteArr = (values).flat();
        noteArr.sort((a, b) => getLineTime(a) - getLineTime(b))
        markdownText.push("# Tag\ [" + term + "\] total: `" + noteArr.length + "` records.")
        for (let i = 0; i < noteArr.length; i++) {
            noteArr[noteArr.length - 1 - i] = noteArr[noteArr.length - 1 - i].replace(/^#/g,"###").replace(/\n#/g,"\n###")
            noteArr[noteArr.length - 1 - i] = "> [!info]+ " + (i + 1) + "\n> " + noteArr[noteArr.length - 1 - i].replace(/\n/g, "\n> ")
            markdownText.push("## " + (i + 1) + "\n" + `${noteArr[noteArr.length - 1 - i]}`)
        }
        const markDownSource = markdownText.filter(line => line.trim() !== "").join("\n")

        this.writeMarkdown(term,markDownSource,el,ctx)
    }
}